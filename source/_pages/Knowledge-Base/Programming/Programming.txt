Programming
===========

.. contents::
   :depth: 2
   :local: 

.. _computer-hardware:

Computer Systems
----------------

Data Storage
^^^^^^^^^^^^

**Endianness**
""""""""""""""

Big-endian systems store the most significant byte of a word in the smallest address and the least significant byte is stored in the largest address. Little-endian systems, in contrast, store the least significant byte in the smallest address.[1]

For example, there is a number in hexadecimal: 0x01234567, with the most significant byte 0x01 and least significant byte 0x67. It is stored within the address range 0x100 through 0x103.[2]

Big-endian:

+---------+--------+--------+--------+---------+
| Address |  0x100 |  0x101 |  0x102 |  0x103  |
+=========+========+========+========+=========+
|  Value  |   0x01 |   0x23 |   0x45 |   0x67  |
+---------+--------+--------+--------+---------+

Little-endian: 

+---------+--------+--------+--------+---------+
| Address |  0x100 |  0x101 |  0x102 |  0x103  |
+=========+========+========+========+=========+
|  Value  |   0x67 |   0x45 |   0x23 |   0x01  |
+---------+--------+--------+--------+---------+

Different processors may follow different conventions. For example the Intel x86 and x86-64 series of processors use the little-endian format while the Motorola 6800 and 68k series of processors use the big-endian format. And newer versions of ARM processors support bi-endian.[1] The most important thing is the consistency. One should keep the used convention in mind when (1) binary data are communicated over a network  between different machines; (2) looking at the byte sequences representing integer data, say inspecting machine-level code generated by a disassembler; (3) programs are written that circumvent the normal type system, say using a data type cast in C.[2]

Data Representation
^^^^^^^^^^^^^^^^^^^

**Integer Representation**
""""""""""""""""""""""""""

**Floating-Point Numbers**
""""""""""""""""""""""""""


**Character Encoding**
""""""""""""""""""""""""

ASCII and Unicode standards are most commonly used for text encoding. See more details in [3].

**Instruction Encoding**
""""""""""""""""""""""""

Instruction codings are usually different across different processors or even the same processor running different operating systems.[2]


Bootstrapping
^^^^^^^^^^^^^

* `How Computers Boot Up <http://duartes.org/gustavo/blog/post/how-computers-boot-up/>`_

.. _operating-system:


Reference
^^^^^^^^^

1. `Endianness in wikipedia <http://en.wikipedia.org/wiki/Endianness>`_

2. `Computer Systems: A Programmer's Perspective, 2nd Ed <http://csapp.cs.cmu.edu>`_

3. `Character Encoding in wikipedia <http://en.wikipedia.org/wiki/Character_encoding>`_

Operating Systems
-----------------

* `Anatomy of a Program in Memory <http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/>`_
* `How the Kernel Manages Your Memory <http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/>`_


Development Tools
-----------------

Using GDB Debugger
^^^^^^^^^^^^^^^^^^

GDB debugger can be a very powerful tool for finding the cause of unexpected behaviors of your program. In a GDB debugging session, you can step your code by line or by instruction and you can also stop your code at a specific line, a function or an address. When your program stops, you can check the values of the variables at that moment. You can even change a variable as you want. Moreover, it allows you to check the status of the stack and inspect how the function are called. The use of GDB may seem not to be as easy as printf() but it can be much more helpful when you're trying to find a deeply hidden bug. Actually it's not as difficut to learn as it seems to be. 

Here are a few good tutorials to get started:

* `GDB Tutorial: A Walkthrough with Examples <http://www.cs.umd.edu/~srhuang/teaching/cmsc212/gdb-tutorial-handout.pdf>`_
* `Using GNU's GDB Debugger <http://www.dirac.org/linux/gdb/index.php>`_
* `Guide to Faster, Less Frustrating Debugging <http://heather.cs.ucdavis.edu/~matloff/UnixAndC/CLanguage/Debug.html>`_
* `RMS's GDB Debugger Tutorial <http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html>`_

The official manual of GDB can be a good reference after you have already learned the basics and want to check more details of a feature:

* `GDB Online Manual <https://sourceware.org/gdb/current/onlinedocs/gdb/>`_

The following are my notes for quick reference of the most frequently used commands. Some of them are from the above materials.

**Background Knowledge**
""""""""""""""""""""""""

It can be very helpful to understand stack and stack frames when you use GDB for debugging. This `page <http://www.dirac.org/linux/gdb/02a-Memory_Layout_And_The_Stack.php#wherearewegoingtogo>`_ from the tutorial "Using GNU's GDB Debugger" gives good explanation about them. 

Briefly speaking, stack is a section of the memory and whenever there is a function call, a stack frame is created in the stack. This stack frame is used to store all related information about this call including the all the `automatic variables <http://en.wikipedia.org/wiki/Automatic_variable>`_ of the newly called function, the return address and the arguments of the called function. In GDB, you can check how the functions are called from each other by inspecting the stack frames. By switching to a stack frame, you get access to variables in that scope, meaning you can check the values of local variables in the corresponding function. You cannot print or modify a variable if that variable doesn't exit in the current stack frame.

In addition to stack and stack frames, check section :ref:`operating-system` for more information about virtual memory and memory layout.

Another thing that you need to remember before starting a gdb debugging session is that you need to use "-g" flag when compiling your code to include debugging information in the generated executable file.

**Frequently Used Commands**
""""""""""""""""""""""""""""

* Starting a debugging session

.. code-block:: bash

    $ gdb <name-of-executable>
    (gdb) run arg1 arg2

Arg1 and arg2 will be remembered and used when you run again. If you want to reset or clear the arguments, use:

.. code-block:: bash

    (gdb) set args <arg1/arg2/.../or none to clear saved args>

If your program is already running, you can still use gdb to debug it.

.. code-block:: bash
    
    $ gdb <name-of-executable> <process-id>

Or you can use the attach command:

.. code-block:: bash
   
    $ gdb
    (gdb) attach <process-id>

* Using breakpoints and watchpoints

.. code-block:: bash

    (gdb) break <function-name> # set break point by function name
    (gdb) break <line-number>
    (gdb) break <file-name:line-number>
    (gdb) break <virtual-memory-address>
    (gdb) break <place-to-break> if <condition>
    (gdb) info breakpoints	# list all all breakpoints and watchpoints
    (gdb) disable n		# n is the breakpoint/watchpoint identifier number from listed info
    (gdb) enable n
    (gdb) clear <function-name>/<line-number>/<file-name:line-number>/<virtual-memory-address>
    (gdb) delete <breakpoint-identifier>
    (gdb) delete		# delete all breakpoints	
    (gdb) continue		# continue execution from breakpoint
   
* Manipulating variables

.. code-block:: bash

    (gdb) ptype <var-name>	# print data type
    (gdb) print <var-name>	# print data value
    (gdb) print /FMT <var-name>	# o:octal,x:hex,d:decimal,u:unsigned decimal,t:binary, 	f:float,a:address,c:char
    (gdb) set <var-name> = <new-value>
    (gdb) print <var-name> = <new-value>

* Stepping and resuming program

.. code-block:: bash

    (gdb) step			# step by line
    (gdb) istep			# step by instruction
    (gdb) next			# continue to next line in current stack frame (including function)
    (gdb) continue
    (gdb) where			# show current line number
    (gdb) list <none>/<line-num>/<range>/<function-name>/<*address>

* Checking stack and stack frames

.. code-block:: bash

    (gdb) backtrace		# display the current stack status
    (gdb) frame			# show current stack frame
    (gdb) frame <frame-num>	# switch to frame <frame-num>
